#!/usr/bin/env python

r"""
Use robot framework API to extract test result data from output.xml generated
by robot tests. For more information on the Robot Framework API, see
http://robot-framework.readthedocs.io/en/3.0/autodoc/robot.result.html
"""

import sys, os
import getopt
import csv
import robot.errors
import re
from datetime import datetime
from robot.api import ExecutionResult
from robot.result.visitor import ResultVisitor
from xml.etree import ElementTree

# Remove the python library path to restore with local project path later.
save_path_0 = sys.path[0]
del sys.path[0]
sys.path.append(os.path.join(os.path.dirname(__file__), "../../../lib"))

from gen_arg import *
from gen_print import *
from gen_valid import *

# Restore sys.path[0].
sys.path.insert(0, save_path_0)

parser = argparse.ArgumentParser(
    usage='%(prog)s [OPTIONS]',
    description="%(prog)s uses a robot framework API to extract test result\
    data from output.xml generated by robot tests. For more information on the\
    Robot Framework API, see\
    http://robot-framework.readthedocs.io/en/3.0/autodoc/robot.result.html and\
    https://gerrit.openbmc-project.xyz/#/c/8885/15/tools/oem/ibm/\
    gen_csv_results.py",
    formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    prefix_chars='-+')

parser.add_argument(
    '--source',
    '-s',
    help='The output.xml robot test result file path.')

parser.add_argument(
    '--dest',
    '-d',
    help='The directory path where the generated .csv files will go.')

parser.add_argument(
    '--version',
    '-v',
    help='Driver version of openbmc firmware which was used during test.')

# Populate stock_list with options we want.
stock_list = [("test_mode", 0), ("quiet", 0), ("debug", 0)]


def exit_function(signal_number=0,
                  frame=None):

    r"""
    Execute whenever the program ends normally or with the signals that we
    catch (i.e. TERM, INT).
    """

    dprint_executing()

    dprint_var(signal_number)

    qprint_pgm_footer()


def signal_handler(signal_number,
                   frame):

    r"""
    Handle signals.  Without a function to catch a SIGTERM or SIGINT, the
    program would terminate immediately with return code 143 and without
    calling the exit_function.
    """

    # Our convention is to set up exit_function with atexit.register() so
    # there is no need to explicitly call exit_function from here.

    dprint_executing()

    # Calling exit prevents us from returning to the code that was running
    # when the signal was received.
    exit(0)


def validate_parms():

    r"""
    Validate program parameters, etc.  Return True or False (i.e. pass/fail)
    accordingly.
    """

    if not valid_file_path(source):
        return False

    if not valid_dir_path(dest):
        return False

    gen_post_validation(exit_function, signal_handler)

    return True


def parse_output_xml(xml_file_path, csv_dir_path, drv_version):

    r"""
    Parse the robot-generated output.xml file and extract various test
    output data. Put the extracted information into a csv file in the "dest"
    folder.

    Description of argument(s):
    xml_file_path  The path to a Robot-generated output.xml file.
    csv_dir_path   The path to the directory that is to contain the .csv files
                   generated by this function.
    drv_version    Version of the openbmc firmware.
    """

    result = ExecutionResult(xml_file_path)
    result.configure(stat_config={'suite_stat_level': 2,
                                  'tag_stat_combine': 'tagANDanother'})

    stats = result.statistics
    print "--------------------------------------"
    print "Total Test Count:\t",\
          stats.total.critical.passed + stats.total.critical.failed
    print "Total Test Failed:\t", stats.total.critical.failed
    print "Total Test Passed:\t", stats.total.critical.passed
    print "Test Start Time:\t", result.suite.starttime
    print "Test End Time:\t\t", result.suite.endtime
    print "--------------------------------------"

    # Use ResultVisitor object and save off the test data info
    class TestResult(ResultVisitor):
        def __init__(self):
            self.testData = []

        def visit_test(self, test):
            self.testData += [test]

    collectDataObj = TestResult()
    result.visit(collectDataObj)

    # Write the result statistics attributes to CSV file
    l_csvlist = []

    # Default Test data
    l_subsys = 'OPENBMC'
    l_test_type = 'FTC'
    l_pse_rel = 'OBMC910'
    l_env = 'HW'
    l_proc = 'P9'
    l_platform_type = ""
    l_func_area = ""

    # System data from XML meta data
    l_system_info = get_system_details(xml_file_path)
    l_driver = l_system_info[0]
    if l_system_info[1]:
        l_platform_type = l_system_info[1]
    else:
        print "System model is not set"
        sys.exit()

    # Default header
    l_header = ['test_start', 'test_end', 'subsys', 'test_type',
                'test_result', 'test_name', 'pse_rel', 'driver',
                'env', 'proc', 'platform_type', 'test_func_area']

    l_csvlist.append(l_header)

    # Generate CSV file onto the path with current time stamp
    l_base_dir = csv_dir_path
    l_timestamp = datetime.utcnow().strftime("%Y-%m-%d-%H-%M-%S")
    # Example: 2017-02-20-08-47-22_Witherspoon.csv
    l_csvfile = l_base_dir + l_timestamp + "_" + l_platform_type + ".csv"

    print "Writing data into csv file:", l_csvfile

    for testcase in collectDataObj.testData:
        # Functional Area: Suite Name
        # Test Name: Test Case Name
        l_func_area = str(testcase.parent).split(' ', 1)[1]
        l_test_name = str(testcase)

        # Test Result pass=0 fail=1
        if testcase.status == 'PASS':
            l_test_result = 0
        else:
            l_test_result = 1

        # Format datetime from robot output.xml to "%Y-%m-%d-%H-%M-%S"
        l_stime = xml_to_csv_time(testcase.starttime)
        l_etime = xml_to_csv_time(testcase.endtime)
        # Data Sequence: test_start,test_end,subsys,test_type,
        #                test_result,test_name,pse_rel,driver,
        #                env,proc,platform_tyep,test_func_area,
        l_data = [l_stime, l_etime, l_subsys, l_test_type, l_test_result,
                  l_test_name, l_pse_rel, l_driver, l_env, l_proc,
                  l_platform_type, l_func_area]
        l_csvlist.append(l_data)

    # Open the file and write to the CSV file
    l_file = open(l_csvfile, "w")
    l_writer = csv.writer(l_file, lineterminator='\n')
    l_writer.writerows(l_csvlist)
    l_file.close()


def xml_to_csv_time(xml_datetime):

    r"""
    Convert the time from %Y%m%d %H:%M:%S.%f format to %Y-%m-%d-%H-%M-%S format
    and return it.

    Description of argument(s):
    datetime  The date in the following format: %Y%m%d %H:%M:%S.%f
              (This is the format typically found in an XML file.)

    The date returned will be in the following format: %Y-%m-%d-%H-%M-%S
    """

    # 20170206 05:05:19.342
    l_str = datetime.strptime(xml_datetime, "%Y%m%d %H:%M:%S.%f")
    # 2017-02-06-05-05-19
    l_str = l_str.strftime("%Y-%m-%d-%H-%M-%S")
    return str(l_str)


def get_system_details(xml_file_path):

    r"""
    Get the system data from output.xml generated by robot and return it.
    The list returned will be in the following order: [driver,platform]

    Description of argument(s):
    xml_file_path  The relative or absolute path to the output.xml file.
    """

    bmc_version = ""
    bmc_platform = ""
    with open(xml_file_path, 'rt') as output:
        tree = ElementTree.parse(output)

    for node in tree.iter('msg'):
        # /etc/os-release output is logged in the XML as msg
        # Example: ${output} = VERSION_ID="v1.99.2-71-gbc49f79-dirty"
        if '${output} = VERSION_ID=' in node.text:
            # Get BMC version (e.g. v1.99.1-96-g2a46570-dirty)
            bmc_version = str(node.text.split("VERSION_ID=")[1])[1:-1]

        # Platform is logged in the XML as msg.
        # Example: ${bmc_model} = Witherspoon BMC
        if '${bmc_model} = ' in node.text:
            bmc_platform = node.text.split(" = ")[1]

    print "BMC Version:", bmc_version
    print "BMC Platform:", bmc_platform
    return [str(bmc_version), str(bmc_platform)]


def main():

    if not gen_get_options(parser, stock_list):
        return False

    if not validate_parms():
        return False

    qprint_pgm_header()

    print "Driver : version", version
    parse_output_xml(source, dest, version)

    return True


# Main

if not main():
    exit(1)
